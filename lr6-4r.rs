use std::io;

// основная функция программы
fn main() {
    // объявляем переменные для хранения размеров площади и количества плиток
    // используем тип i64 для поддержки больших чисел
    let mut n: i64 = 0;
    let mut m: i64 = 0;
    let mut t: i64 = 0;

    // создаем строку для чтения входных данных
    let mut input = String::new();

    // читаем первую строку с входными данными
    io::stdin().read_line(&mut input).expect("не удалось прочитать строку");
    // разбиваем строку по пробелам и парсим числа
    let parts: Vec<&str> = input.trim().split_whitespace().collect();

    // проверяем, что введено ровно три числа
    if parts.len() != 3 {
        println!("Ошибка: необходимо ввести три числа: n, m, t");
        return;
    }

    // парсим числа из строки
    n = parts[0].parse().expect("не удалось преобразовать n в число");
    m = parts[1].parse().expect("не удалось преобразовать m в число");
    t = parts[2].parse().expect("не удалось преобразовать t в число");

    // проверка, чтобы размеры были не меньше 3
    if n < 3 || m < 3 {
        println!("Ошибка: размеры площади должны быть ≥ 3");
        return; // завершение программы
    }

    // проверка, чтобы количество плиток было не меньше 1
    if t < 1 {
        println!("Ошибка: количество плиток должно быть ≥ 1");
        return; // завершение программы
    }

    // проверка, чтобы плиток не было слишком много (не покрывали бы всю площадь)
    if t >= n * m {
        println!("Ошибка: плиток слишком много, они покрывают всю площадь");
        return; // завершение программы
    }

    // устанавливаем границы бинарного поиска для ширины дорожки
    // левая граница — 0 (минимальная ширина)
    let mut left: i64 = 0;
    // правая граница — половина минимального из размеров (максимально возможная ширина)
    let mut right: i64 = std::cmp::min(n, m) / 2;

    // переменная для хранения максимальной найденной ширины
    let mut max_width: i64 = 0;

    // начинаем цикл бинарного поиска
    while left <= right {
        // вычисляем среднюю ширину (текущий кандидат)
        let mid = (left + right) / 2;

        // вычисляем внутренние размеры площади после вычитания дорожки
        let inner_n = n - 2 * mid;
        let inner_m = m - 2 * mid;

        // проверяем, чтобы внутренние размеры были положительными
        if inner_n <= 0 || inner_m <= 0 {
            // если внутренний размер не положителен, уменьшаем правую границу
            right = mid - 1;
            continue; // переходим к следующей итерации
        }

        // вычисляем общую площадь всей площади
        let total_area = n * m;
        // площадь внутренней области
        let inner_area = inner_n * inner_m;
        // площадь дорожки — разница между общей и внутренней площадью
        let road_area = total_area - inner_area;

        // если площадь дорожки не превышает допустимое значение t
        if road_area <= t {
            // обновляем максимум ширины
            max_width = mid;
            // ищем дальше в правой части (больше ширина)
            left = mid + 1;
        } else {
            // если дорожки слишком много, ищем меньшую ширину
            right = mid - 1;
        }
    }

    // выводим найденное максимальное значение ширины дорожки
    println!("{}", max_width);
}
