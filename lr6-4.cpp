#include <iostream>
#include <cstdint> 
#include <algorithm> 
using namespace std;


int main() {
    int64_t n, m, t; // объявление переменных для размеров площади и количества плиток

    // чтение входных данных
    cin >> n >> m >> t;

    // проверка, чтобы размеры были не меньше 3
    if (n < 3 || m < 3) {
        cout << "Ошибка: размеры площади должны быть ≥ 3." << endl;
        return 1; // завершение программы с кодом ошибки
    }

    // проверка, чтобы количество плиток было не меньше 1
    if (t < 1) {
        cout << "Ошибка: количество плиток должно быть ≥ 1." << endl;
        return 1; // завершение программы с кодом ошибки
    }

    // проверка, чтобы плиток не было слишком много (не покрывали бы всю площадь)
    if (t >= n * m) {
        cout << "Ошибка: плиток слишком много, они покрывают всю площадь." << endl;
        return 1; // завершение программы с кодом ошибки
    }

    // установка границ бинарного поиска для ширины дорожки
    int64_t left = 0; // левая граница (минимальная ширина)
    int64_t right = min(n, m) / 2; // правая граница (максимальная возможная ширина)
    int64_t maxWidth = 0; // переменная для хранения результата

    // цикл бинарного поиска
    while (left <= right) {
        int64_t mid = (left + right) / 2; // вычисляем среднюю ширину
        int64_t innerN = n - 2 * mid; // внутренний размер по вертикали
        int64_t innerM = m - 2 * mid; // внутренний размер по горизонтали

        // проверка, чтобы внутренний размер был положительным
        if (innerN <= 0 || innerM <= 0) {
            right = mid - 1; // уменьшаем правую границу
            continue; // переходим к следующей итерации
        }

        // вычисляем общую площадь
        int64_t totalArea = static_cast<int64_t>(n) * m;
        // площадь внутренней области
        int64_t innerArea = static_cast<int64_t>(innerN) * innerM;
        // площадь дорожки (разница между общей и внутренней)
        int64_t roadArea = totalArea - innerArea;

        // если площадь дорожки не превышает t
        if (roadArea <= t) {
            maxWidth = mid; // обновляем максимум
            left = mid + 1; // ищем дальше в правой части
        } else {
            right = mid - 1; // ищем в левой части
        }
    }

    // вывод результата
    cout << maxWidth << endl;

    return 0; 
}
